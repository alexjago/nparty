//! The booths-to-SA1s *projection* phase.
//!   
//! The AEC have given us a
//! "this many people from this SA1 voted at this booth"
//! spreadsheet. It doesn't exactly correspond to either Reps or Senate numbers
//! but we shall simply scale slightly for Senate voter numbers.
//!   
//! We are basically performing a matrix product:
//! `[sa1s; booths] * [booths; orders] = [sa1s; orders]`

// This file corresponds to `SA1s_Multiplier.py`

use super::booths::{group_combos, Parties};
use super::utils::{PrefsMap, StateAb};
use color_eyre::eyre::{bail, Context, ContextCompat, Result};
use std::collections::{BTreeMap, BTreeSet};
use std::fs::create_dir_all;
use std::path::Path;
use tracing::{debug, info, trace};

/// Convert a header to a column index in the SA1-Booth file.
#[allow(non_camel_case_types)]
#[repr(usize)]
enum sa1col {
    year = 0,
    state_ab = 1,
    div_nm = 2,
    SA1_id = 3,
    #[allow(dead_code)]
    pp_id = 4,
    pp_nm = 5,
    votes = 6,
}

/// Load up NPP Booth Data from file.
///
/// `combinations` is a list of group-code orderings, as output by [`group_combos`].  
///
/// This is the equivalent to the `[booths; orders]` matrix.
fn load_npp_booths(combinations: &[String], npp_booths_path: &Path) -> Result<PrefsMap> {
    // Five fixed fields at the start, plus all the combinations, plus a total at the end:
    // ID, Division, Booth, Latitude, Longitude, {combinations ...}, Total
    // we don't actually care about ID, Latitude or Longitude,
    // as IDs have been known to be inconsistent across files,
    // and Lat/Lon are for the booths, not the SA1s

    let mut booths: PrefsMap = BTreeMap::new();
    let mut total_votes: f64 = 0.0;

    let mut booths_rdr = csv::ReaderBuilder::new()
        .flexible(true)
        .has_headers(true)
        .from_path(npp_booths_path)?;

    for record in booths_rdr.records() {
        let row = record?;
        let divbooth = row[1].to_owned() + "_" + &row[2];

        let mut boothvotes: Vec<f64> = Vec::with_capacity(combinations.len() + 1);

        for i in row.iter().skip(5) {
            let val = i.parse::<f64>().unwrap_or(0.0);
            total_votes += val;
            boothvotes.push(val);
        }
        if boothvotes.len() < combinations.len() + 1 {
            boothvotes.resize(combinations.len() + 1, 0.0);
        }

        booths.insert(divbooth, boothvotes);
    }
    trace!("\tTotal NPP votes: {}", total_votes / 2.0); // div2 because we had the total already
    Ok(booths)
}

/// Actually write the output (as a CSV).
///
/// * `sa1_prefs_path`: the path to write it to
/// * `combinations`: every possible combination of group codes (see [`group_combos`]), which will be most of the headers.
/// * `outputn`: a map of from SA1 IDs to preference results (in the corresponding order to `combinations`)
///
/// The column order is `SA1_ID`, then all of the `combinations`.
fn write_sa1_prefs(
    sa1_prefs_path: &Path,
    combinations: &[String],
    outputn: BTreeMap<String, Vec<f64>>,
) -> Result<()> {
    // having summed it all up...
    use std::iter::once;

    create_dir_all(
        sa1_prefs_path
            .parent()
            .context("couldn't perform path conversion")?,
    )?;
    let mut sa1_wtr = csv::Writer::from_path(sa1_prefs_path)?;

    let header = once("SA1_id")
        .chain(combinations.iter().map(String::as_str))
        .chain(once("Total"));

    sa1_wtr
        .write_record(header)
        .context("error writing SA1_prefs header")?;

    for (id, row) in outputn {
        let out = once(id).chain(row.iter().map(ToString::to_string));
        sa1_wtr
            .write_record(out)
            .context("error writing SA1_prefs line")?;
    }

    sa1_wtr.flush().context("error finalising SA1_prefs")?;
    Ok(())
}

/// Were there errors of correspondence between the SA1-Booth file and the NPP-Booth file?
///
/// * `skipped`: map of booths : votes, where the booth was not found in the NPP-Booth file
/// * `sa1_booth_total`: the total vote count in the SA1-Booth file
/// * `output_total`: the total vote count in the output file
/// * `booths`: the output from [`load_npp_booths`]
/// * `divbooths_seen`: the set of divbooths found in the SA1-Booth file.
///
/// This function effectively performs `booths.keys - divbooths_seen` to determine if any booths are missing from
/// the SA1-Booth file, or spuriously generated by [`crate::booths::booth_npps`].
fn print_diagnostics(
    skipped: BTreeMap<String, f64>,
    sa1_booth_total: f64,
    output_total: f64,
    booths: &PrefsMap,
    divbooths_seen: &BTreeSet<String>,
) {
    debug!("\tSA1 Booths votes:\t{:8}", sa1_booth_total);
    debug!("\tOutput SA1s votes:\t{:8.0}", output_total / 2.0); // div2 as total included in sum
    if (sa1_booth_total - (output_total / 2.0)).abs() > 1.0 {
        debug!(
            "\tThe following booths had no corresponding NPP Preferences recorded. This has been known to happen.",
        );
        for (k, v) in skipped {
            let (div, booth) = k.split_once('_').unwrap();
            debug!("\t\t{:8}\t{:32}\t{:5}", div, booth, v);
        }
    }
    // Perform and report the set difference between `booths.keys` and `divbooths_seen`
    let booth_keys = booths
        .keys()
        .map(String::clone)
        .collect::<BTreeSet<String>>();
    let whoopsie = booth_keys
        .difference(divbooths_seen)
        .collect::<BTreeSet<&String>>();
    if !whoopsie.is_empty() {
        debug!("The following booths, if any, appear in the NPP Preferences file but not in the SA1-Booths file:");
        for k in whoopsie {
            let total = *(booths.get(k).and_then(|v| v.last()).unwrap_or(&0.0));
            let (div, booth) = k.split_once('_').unwrap();
            debug!("\t\t{:8}\t{:32}\t{:5}", div, booth, total);
        }
    }
}

/// Perform the projection from booths to SA1s.
///
/// * `parties`: the groups being considered on a `preferred` basis.
/// * `state`: the relevant state or territory
/// * `year`: the year of the election
/// * `npp_booths_path`: the location of the file created by [`crate::booths::booth_npps`].
/// * `sa1_breakdown_path`: the SA1-Booths correspondence.
/// * `sa1_prefs_path`: the output file.
pub fn project(
    parties: &Parties,
    state: StateAb,
    year: &str,
    npp_booths_path: &Path,
    sa1_breakdown_path: &Path,
    sa1_prefs_path: &Path,
) -> Result<()> {
    info!("\tProjecting results onto SA1s");

    let combinations = {
        // potential soundness issue: is this going to work out the same order?
        // BTreeMap for Parties in general should fix that
        let mut partykeys: Vec<&str> = Vec::new();
        for k in parties.keys() {
            partykeys.push(k);
        }
        group_combos(&partykeys)
    };

    // *** Load up NPP-Booth data ***
    let booths = load_npp_booths(&combinations, npp_booths_path)?;

    // *** Load up SA1 data ***
    // This is the [sa1s; booths] matrix equivalent
    // Since it's so sparse we prefer a map to an array

    let mut sa1_rdr = csv::ReaderBuilder::new()
        .flexible(true)
        .has_headers(true)
        .from_path(sa1_breakdown_path)?;

    let mut outputn: PrefsMap = BTreeMap::new(); // Our numerical ultimate output. Indexed by SA1 ID

    // Diagnostics
    let mut skipped: BTreeMap<String, f64> = BTreeMap::new();
    let mut sa1_booth_total: f64 = 0.0;
    let mut output_total: f64 = 0.0;
    let mut divbooths_seen: BTreeSet<String> = BTreeSet::new();

    let mut row = csv::StringRecord::new();
    while sa1_rdr.read_record(&mut row)? {
        let sa1_id = row
            .get(sa1col::SA1_id as usize)
            .context("Missing SA1_id field in record")?
            .to_owned();

        if row
            .get(sa1col::state_ab as usize)
            .context("Missing state_ab field in record")?
            != state.to_string()
        {
            // All SA1s nationwide are in the one file - so any row with the wrong state can be safely skipped.
            // This is a performance optimisation really; we're avoiding having to construct `divbooth` etc.
            continue;
        }
        if row
            .get(sa1col::year as usize)
            .context("Missing year field in record")?
            != year
        {
            // However, the wrong year is definitely cause for concern. Bail.
            bail!(
                "Problem in `{}`: Unsupported election year: {}. Exiting.",
                sa1_breakdown_path.display(),
                year
            );
        }
        let divbooth = row[sa1col::div_nm as usize].to_owned() + "_" + &row[sa1col::pp_nm as usize];
        divbooths_seen.insert(divbooth.clone());

        // The number of votes from a booth attributed to this SA1
        let sa1_booth_votes: f64 = row
            .get(sa1col::votes as usize)
            .and_then(|x| x.parse::<f64>().ok())
            .unwrap_or(0.0_f64);

        sa1_booth_total += sa1_booth_votes;

        if let Some(boothvotes) = booths.get(&divbooth) {
            // ^^ Rarely, there's no entry if no formal votes at a booth or if the prior checks aren't sufficient

            // The total number of Senate votes cast at the booth
            let boothtotal = boothvotes
                .last()
                .with_context(|| format!("No vote records for {:?}", &divbooth.split_once('_')))?;

            let output_row = outputn
                .entry(sa1_id)
                .or_insert_with(|| vec![0.0_f64; combinations.len() + 1]);

            if (*boothtotal) > 0.0 {
                for (i, w) in boothvotes.iter().enumerate() {
                    // w: the vote share for a preference combo
                    let val = (sa1_booth_votes * w) / boothtotal;
                    // doing it in one go produces slightly different results to the Python,
                    // which is concerning...
                    *output_row.get_mut(i).unwrap() += val;
                    output_total += val;
                }
            } else {
                trace!("Booth {} has an entry, but total of zero votes.", divbooth);
            }
        } else {
            *skipped.entry(divbooth.clone()).or_insert(0.0) += sa1_booth_votes;
            trace!(
                "No NPP prefs found for {}; skipping {} votes from {}",
                divbooth,
                sa1_booth_votes,
                sa1_id
            );
        }
    }

    // Diagnostics
    print_diagnostics(
        skipped,
        sa1_booth_total,
        output_total,
        &booths,
        &divbooths_seen,
    );

    // Actually write the output
    write_sa1_prefs(sa1_prefs_path, &combinations, outputn)?;
    info!("\tProjection Done!");
    Ok(())
}
